<<<<<<< HEAD
/*
  JS for devices page functionality.
  Author: Calvin Lee
  Description: Provide browser-sided Joi functionality for validating device attribute inputs and
    displaying a user's devices on the page.
  Notes: 
*/

// use browser-side Joi to reduce number of get/post calls on the server
const Joi = window.joi;

// Temporary holding variables to track the name/kWh of a device if a user wants to edit
// or delete one.
let currentDevice = undefined;
let currentKWH = undefined;

// List of possible devices and their estimated kwh values that the server knows,
// loaded in when the page loads
let possibleDevices = undefined;

/*
  Event listener for the ? button that sets the height of the display to the same height as
  the add device form, so the display doesn't change size while scrolling to a new carousel item.
  Also changes the button's text.
*/
let helpButtonToggle = true;
document.getElementById("device-help").addEventListener('click', () => {
  document.getElementById("help-text").style.height = document.getElementById("add-device-form").offsetHeight + "px";

  if (helpButtonToggle) {
    document.getElementById("device-help").innerHTML = "Back";
  }
  else {
    document.getElementById("device-help").innerHTML = "?";
  }
  helpButtonToggle = !helpButtonToggle;
});


/*
  Event listener for the Add new device button on the device page, to reset the active carousel
  item and ? button to its original text if the user exits during the help text carousel item.
*/
document.getElementById("device-add").addEventListener('click', () => {
  document.getElementById("add-device-form").classList.add("active");
  document.getElementById("help-text").classList.remove("active");
  helpButtonToggle = true;
  document.getElementById("device-help").innerHTML = "?";
});


/*
  Populate the search textbox with options based on the list of devices in the json file.
  Note: This code was generated by GPT, with modifications to fit our application.
*/
document.addEventListener("DOMContentLoaded", async function() {
  // Get the list of available devices first
  var response = await fetch('/loadDevices');
  possibleDevices = await response.json();

  var options = [];
  for (let i = 0; i < possibleDevices.length; i++) {
    options = options.concat(possibleDevices[i].name);
  }

  // Get the elements for the textbox and the div containing the options
  const deviceNameBox = document.getElementById("deviceName");
  const dropdown = document.getElementById("deviceDrop");

  // Add an event listener that watches in the textbox, applying the filter as text is being typed
  deviceNameBox.addEventListener("input", function() {
      // Reset the placeholder text for the wattage input
      var wattageInput = document.getElementById("deviceWattage");
      wattageInput.setAttribute("placeholder", `Units in watts`);

      const filter = deviceNameBox.value.toLowerCase();
      dropdown.innerHTML = '';
      dropdown.style.width = "" + deviceNameBox.offsetWidth + "px";
      
      if (filter) {
        // Get the list of devices that contain the current text input
        const filteredOptions = options.filter(option => option.toLowerCase().includes(filter));

        // Limit to maximum of 5 devices shown in the list
        filteredOptions.slice(0, 5).forEach(option => {
          const optionElement = document.createElement("div");
          optionElement.classList.add("option");
          optionElement.textContent = option;

          // Add an event listener to each search result to fill in the textbox if clicked and to
          // remove the dropdown filter
          optionElement.addEventListener("click", function() {
              deviceNameBox.value = option;
              dropdown.innerHTML = '';
              dropdown.style.display = 'none';

              // Also update the placeholder values to show the expected min/max wattage values
              // This filter will always find one, since we know the name exists
              let findDevice = possibleDevices.filter(device => device.name == option);
              let device = findDevice[0];
              wattageInput.setAttribute("placeholder", `Expecting ${device.min} to ${device.max} watts`);
          });

          dropdown.appendChild(optionElement);
        });

        // Display the dropdown if there's anything in it, otherwise don't
        dropdown.style.display = filteredOptions.length ? 'block' : 'none';
      }
      else {
        dropdown.style.display = 'none';
      }
  });

  // Remove the dropdown display if the user clicks away
  document.addEventListener("click", function(event) {
    if (!event.target.closest('#deviceName')) {
      dropdown.style.display = 'none';
    }
  });
});


/*
  Add an event listener to the body of the table, so that if no devices were detected,
  a message is shown to the user telling them so.
*/
document.addEventListener("DOMContentLoaded", (e) => {
  let tableBody = document.getElementById("device-table");
  if (!tableBody.rows.length) {
    tableBody.innerHTML = `<tr><td></td><td colspan="3">You have no devices yet!</td></tr>`;
  }
});


/*
  Add an event listener to each of the edit and delete buttons to track the device being targeted,
  so that the correct device can be sent to the server for querying and that the correct
  information can be displayed on the edit modal.
*/
let allEditButtons = document.querySelectorAll(".edit-delete");
allEditButtons.forEach(editButton => {
  editButton.addEventListener("click", (e) => {

    currentDevice = e.target.getAttribute("data-device");
    currentKWH = e.target.getAttribute("data-kwh");

    document.getElementById("edit-device-name").innerHTML = currentDevice;
    document.getElementById("edit-device-kwh").innerHTML = currentKWH;
  });
});


/*
  Add an event listener to the add device submission button to add a new device
*/
document.getElementById("add-submit").addEventListener("click", (e) => {
  e.preventDefault();

  let newDeviceName = document.getElementById("deviceName").value;
  let newDeviceWattage = document.getElementById("deviceWattage").value;
  let newDeviceUsage = document.getElementById("deviceUsage").value;
  let errorBox = document.getElementById("add-error");

  // Validate that the input device is from the list of available devices
  // Exit out of function and display an error message if not found
  var options = [];
  for (let i = 0; i < possibleDevices.length; i++) {
    options = options.concat(possibleDevices[i].name);
  }

  const result = options.includes(newDeviceName);
  if (!result) {
    errorBox.innerHTML = "Please enter a device from the list.";
    return;
  }

  // Validate the values using Joi first before sending to server to add
  const schema = Joi.object({
    device: Joi.string().required(),
    kw:     Joi.number().min(0).max(5000),
    usage:  Joi.number().min(0).max(24)
  });
  var validationResult = schema.validate({
    device: newDeviceName, kw: newDeviceWattage, usage: newDeviceUsage});

  // Display a relevant error message if any of the inputs are not right
  if (validationResult.error != null) {
    let errorMsg = validationResult.error.details[0].message;
    if (errorMsg.includes("kw") && errorMsg.includes("greater")) {
      errorBox.innerHTML = "Wattage must be greater than 0!";
    }
    else if (errorMsg.includes("kw") && errorMsg.includes("less")) {
      errorBox.innerHTML = "Wattage looks way to high! Please check again.";
    }
    else if (errorMsg.includes("kw")) {
      errorBox.innerHTML = "Please enter a valid number for wattage.";
    }
    else if (errorMsg.includes("usage")) {
      errorBox.innerHTML = "Usage must be between 0 and 24 hours.";
    }
    else if (errorMsg.includes("device")) {
      errorBox.innerHTML = "You need to enter a device.";
    }
    return;
  }

  // Calculate kwh. If the user didn't know the device wattage/usage, give the average
  let kwh = newDeviceWattage * newDeviceUsage / 1000;
  if (newDeviceWattage == 0 && newDeviceUsage == 0) {
    let deviceNames = [];
    for (let i = 0; i < possibleDevices.length; i++) {
      deviceNames = deviceNames.concat(possibleDevices[i].name);
    }
    let deviceIndex = deviceNames.indexOf(newDeviceName);
    kwh = possibleDevices[deviceIndex].kWh;
  }

  document.getElementById("add-error").innerHTML = "<br/>";
  window.location.href = `/addDevice?device=${encodeURIComponent(newDeviceName)}`
      + `&kwh=${encodeURIComponent(kwh)}`;
});


/*
  Add an event listener to the edit device submission button to edit the kWh rating of
  a device.
*/
document.getElementById("edit-submit").addEventListener("click", async (e) => {
  e.preventDefault();

  let errorBox = document.getElementById("edit-error");
  let newKWH = document.getElementById("editKWH").value;

  if (newKWH == currentKWH) {
    errorBox.innerHTML = "The new value is the same as the previous value.";
    return;
  }

  // Validate the new value with Joi
  const schema = Joi.object( {kwh: Joi.number().min(0).max(12000).required()} );
  var validationResult = schema.validate({kwh: newKWH});

  // Display a relevant error message if the number isn't valid
  if (validationResult.error != null) {
    let errorMsg = validationResult.error.details[0].message;
    if (errorMsg.includes("kwh") && errorMsg.includes("greater")) {
      errorBox.innerHTML = "Rating must be greater than 0!";
    }
    else if (errorMsg.includes("kwh") && errorMsg.includes("less")) {
      errorBox.innerHTML = "Rating looks way to high! Please check again.";
    }
    else if (errorMsg.includes("kwh")) {
      errorBox.innerHTML = "Please enter a valid number for wattage.";
    }
    return;
  }

  errorBox.innerHTML = "<br/>";
  window.location.href = `/editDevice?device=${encodeURIComponent(currentDevice)}`
      + `&kwh=${encodeURIComponent(newKWH)}`;
});


/*
  Add an event listener to the delete device submission button to remove the device from
  the user's list.
*/
document.getElementById("delete-submit").addEventListener("click", async (e) => {
  e.preventDefault();

  window.location.href = `/deleteDevice?device=${encodeURIComponent(currentDevice)}`
      + `&kwh=${encodeURIComponent(currentKWH)}`;
});
=======
document.addEventListener("DOMContentLoaded", async function () {
  try {
    const response = await fetch('/dashboardDevices');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const json = await response.text();
    console.log('Fetched JSON:', json); // Log the fetched JSON string

    userDevicesHistory = JSON.parse(json);

    // Check and duplicate device history for missing dates
    checkAndDuplicateDeviceHistory();

    google.charts.load('current', { 'packages': ['corechart'] });
    google.charts.setOnLoadCallback(() => {
      drawPieChart(userDevicesHistory);
      drawBarGraph(userDevicesHistory, 'week'); // Default to weekly
    });
  } catch (error) {
    console.error('Error loading devices:', error);
  }
});

const period = document.querySelectorAll('a');

// Convert NodeList to an array and select only the first 3 elements
const firstThreeLinks = Array.from(period).slice(0, 3);

firstThreeLinks.forEach(time => {
  time.addEventListener('click', (event) => {
    event.preventDefault();
    firstThreeLinks.forEach(t => t.className = 'nav-link text-success');
    time.className = 'nav-link active text-success';
    filterData(time.textContent.toLowerCase(), 'pie');
  });
});

// Convert NodeList to an array and select only the second 3 elements
const secondsThreeLinks = Array.from(period).slice(3, 6);

secondsThreeLinks.forEach(time => {
  time.addEventListener('click', (event) => {
    event.preventDefault();
    secondsThreeLinks.forEach(t => t.className = 'nav-link text-success');
    time.className = 'nav-link active text-success';
    filterData(time.textContent.toLowerCase(), 'bar');
  });
});

let userDevicesHistory = [];

function checkAndDuplicateDeviceHistory() {
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  if (userDevicesHistory.length === 0) return;

  // Find the latest entry
  let latestEntry = userDevicesHistory[userDevicesHistory.length - 1];
  let latestDate = new Date(latestEntry.date);
  latestDate.setHours(0, 0, 0, 0);

  while (latestDate < today) {
    latestDate.setDate(latestDate.getDate() + 1);
    const newEntry = {
      date: latestDate.toISOString(),
      user_devices: JSON.parse(JSON.stringify(latestEntry.user_devices))
    };
    userDevicesHistory.push(newEntry);
  }
}

// Filter data based on period
function filterData(period, chartType) {
  const now = new Date();
  let filteredData = [];

  console.log(period);
  console.log(`Filtering data for period: ${period}`);

  if (period === 'week') {
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    filteredData = userDevicesHistory.filter(entry => {
      const entryDate = new Date(entry.date);
      console.log(`Entry date: ${entryDate}, Week ago: ${weekAgo}`);
      return entryDate >= weekAgo;
    });
  } else if (period === 'month') {
    const monthAgo = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
    filteredData = userDevicesHistory.filter(entry => {
      const entryDate = new Date(entry.date);
      console.log(`Entry date: ${entryDate}, Month ago: ${monthAgo}`);
      return entryDate >= monthAgo;
    });
  } else if (period === 'year') {
    const yearAgo = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
    filteredData = userDevicesHistory.filter(entry => {
      const entryDate = new Date(entry.date);
      console.log(`Entry date: ${entryDate}, Year ago: ${yearAgo}`);
      return entryDate >= yearAgo;
    });
  }

  console.log(`Filtered data length: ${filteredData.length}`);

  if (chartType === 'pie') {
    drawPieChart(filteredData);
  } else if (chartType === 'bar') {
    drawBarGraph(filteredData, period);
  }
}

// Draws the pie chart onto the ejs file
// Utilizes Google Charts open-source pie chart to display visuals
function drawPieChart(filteredData) {
  if (!filteredData.length) {
    console.error('No devices data available');
    return;
  }

  const dataArray = [['Device', 'kWh']];
  const deviceTotals = {};

  filteredData.forEach(entry => {
    entry.user_devices.forEach(device => {
      deviceTotals[device.name] = (deviceTotals[device.name] || 0) + parseFloat(device.kWh);
    });
  });

  for (const [name, kWh] of Object.entries(deviceTotals)) {
    dataArray.push([name, kWh]);
  }

  const data = google.visualization.arrayToDataTable(dataArray);

  const colors = generateColors(Object.keys(deviceTotals).length);

  const options = {
    title: 'Energy Consumption per Device',
    legend: { position: 'none' },
    width: '100%',
    height: 400,
    colors: colors
  };

  const chart = new google.visualization.PieChart(document.getElementById('piechart'));
  google.visualization.events.addListener(chart, 'ready', () => {
    createCustomLegend(deviceTotals, colors);
  });
  chart.draw(data, options);
}

function generateColors(numberOfColors) {
  const colors = [];
  const baseColors = ['#76A7FA', '#FF6347', '#FFD700', '#ADFF2F', '#32CD32', '#FF4500', '#8A2BE2', '#FF1493', '#00CED1', '#20B2AA'];
  for (let i = 0; i < numberOfColors; i++) {
    colors.push(baseColors[i % baseColors.length]);
  }
  return colors;
}

function createCustomLegend(deviceTotals, colors) {
  const devicesWithColors = [];

  let index = 0;
  for (const [name, kWh] of Object.entries(deviceTotals)) {
    devicesWithColors.push({
      name: name,
      kWh: kWh,
      color: colors[index]
    });
    index++;
  }

  devicesWithColors.sort((a, b) => b.kWh - a.kWh);

  const midpoint = Math.ceil(devicesWithColors.length / 2);
  const leftColumn = devicesWithColors.slice(0, midpoint);
  const rightColumn = devicesWithColors.slice(midpoint);

  let legendHtml = '<div style="display: flex; justify-content: center;">';
  legendHtml += '<ul style="list-style: none; padding: 0; margin: 0 20px;">';
  leftColumn.forEach(device => {
    const deviceName = device.name.charAt(0).toUpperCase() + device.name.slice(1);
    legendHtml += `<li><span style="display: inline-block; width: 10px; height: 10px; background-color: ${device.color}; margin-right: 8px;"></span>${deviceName}</li>`;
  });
  legendHtml += '</ul>';

  legendHtml += '<ul style="list-style: none; padding: 0; margin: 0 20px;">';
  rightColumn.forEach(device => {
    const deviceName = device.name.charAt(0).toUpperCase() + device.name.slice(1);
    legendHtml += `<li><span style="display: inline-block; width: 10px; height: 10px; background-color: ${device.color}; margin-right: 8px;"></span>${deviceName}</li>`;
  });
  legendHtml += '</ul>';
  legendHtml += '</div>';

  const legendDiv = document.getElementById('piechart-legend');
  legendDiv.innerHTML = legendHtml;
}

function drawBarGraph(filteredData, period) {
  if (!filteredData.length) {
    console.error('No devices data available');
    return;
  }

  let dataArray = [["Date", "kWh", { role: "style" }, "CO2e (kg)", { role: "style" }]];

  if (period === 'week') {
    const dailyData = {};

    // Initialize dailyData for the past 7 days
    for (let i = 0; i < 7; i++) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const dateString = date.toISOString().split('T')[0];
      dailyData[dateString] = { kWh: 0, CO2e: 0 };
    }

    filteredData.forEach(entry => {
      const entryDate = new Date(entry.date).toISOString().split('T')[0];
      if (dailyData[entryDate]) {
        entry.user_devices.forEach(device => {
          const kWh = parseFloat(device.kWh);
          dailyData[entryDate].kWh += kWh;
          dailyData[entryDate].CO2e += (kWh * 127.82) / 1000;
        });
      }
    });

    for (const [date, data] of Object.entries(dailyData)) {
      dataArray.push([date, data.kWh, "color: #76A7FA", data.CO2e, "color: #FF6347"]);
    }
  } else if (period === 'month') {
    const weeklyData = {};

    // Initialize weeklyData for the past 4 weeks
    for (let i = 0; i < 4; i++) {
      const weekStart = new Date();
      weekStart.setDate(weekStart.getDate() - i * 7);
      const weekString = `Week ${4 - i}`;
      weeklyData[weekString] = { kWh: 0, CO2e: 0 };
    }

    filteredData.forEach(entry => {
      const entryDate = new Date(entry.date);
      const weekIndex = Math.floor((Date.now() - entryDate) / (7 * 24 * 60 * 60 * 1000));
      if (weekIndex < 4) {
        const weekString = `Week ${4 - weekIndex}`;
        entry.user_devices.forEach(device => {
          const kWh = parseFloat(device.kWh);
          weeklyData[weekString].kWh += kWh;
          weeklyData[weekString].CO2e += (kWh * 127.82) / 1000;
        });
      }
    });

    for (const [week, data] of Object.entries(weeklyData)) {
      dataArray.push([week, data.kWh, "color: #76A7FA", data.CO2e, "color: #FF6347"]);
    }
  } else if (period === 'year') {
    const monthlyData = {};

    // Initialize monthlyData for the past 12 months
    for (let i = 0; i < 12; i++) {
      const date = new Date();
      date.setMonth(date.getMonth() - i);
      const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
      monthlyData[dateString] = { kWh: 0, CO2e: 0 };
    }

    filteredData.forEach(entry => {
      const entryDate = new Date(entry.date);
      const entryMonth = `${entryDate.getFullYear()}-${(entryDate.getMonth() + 1).toString().padStart(2, '0')}`;
      if (monthlyData[entryMonth]) {
        entry.user_devices.forEach(device => {
          const kWh = parseFloat(device.kWh);
          monthlyData[entryMonth].kWh += kWh;
          monthlyData[entryMonth].CO2e += (kWh * 127.82) / 1000;
        });
      }
    });

    for (const [month, data] of Object.entries(monthlyData)) {
      dataArray.push([month, data.kWh, "color: #76A7FA", data.CO2e, "color: #FF6347"]);
    }
  }

  const data = google.visualization.arrayToDataTable(dataArray);

  const view = new google.visualization.DataView(data);
  view.setColumns([0, 1, 2, 3, 4]);

  const options = {
    title: period === 'week' ? "Daily Energy Consumption and CO2e for the Past Week" :
           period === 'month' ? "Weekly Energy Consumption and CO2e for the Past Month" :
           "Monthly Energy Consumption and CO2e for the Past Year",
    width: "100%",
    height: 400,
    bar: { groupWidth: "80%" },
    legend: { position: "none" },
    hAxis: {
      textStyle: { fontSize: 10 } // Adjust font size to fit longer labels if necessary
    },
    series: {
      0: { color: '#76A7FA' },
      1: { color: '#FF6347' }
    }
  };

  const chart = new google.visualization.ColumnChart(document.getElementById("columnchart_values"));
  chart.draw(view, options);
}
>>>>>>> dev-dashboard-graphs
